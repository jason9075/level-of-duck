<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Level of Duck</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="stylesheet" href="style.css" />
</head>

<body>
    <div id="controls">
        <div id="cameraPosition"></div>
        <label>
            Instances:
            <span id="instanceCount">1</span>
        </label>
        <label>
            Use LOD
            <input type="checkbox" id="useLODModel" checked />
        </label>
        <label>
            LOD Simplify Ratio: <span id="lodRatioValue">80%</span><br />
            <input type="range" id="lodRatio" min="0" max="1" step="0.01" value="0.8" />
        </label>
        <label>
            LOD Distance: <span id="lodDistanceValue">5</span><br />
            <input type="range" id="lodDistance" min="0" max="250" value="5" />
        </label>
        <label>
            Add if FPS over 50
            <button id="autoAddButton">Start</button>
        </label>
        <label>
            Set Number of Ducks:
            <input type="number" id="numDucks" min="1" max="10000" value="1" />
        </label>
    </div>
    <div id="rotation">
        <label style="color: red">
            Rotate X:
            <input type="range" id="rotateX" min="-180" max="180" value="0" />
        </label>
        <label style="color: green">
            Rotate Y:
            <input type="range" id="rotateY" min="-180" max="180" value="0" />
        </label>
        <label style="color: blue">
            Rotate Z:
            <input type="range" id="rotateZ" min="-180" max="180" value="0" />
        </label>
    </div>
    <script src=" https://cdn.jsdelivr.net/npm/stats-js@1.0.1/build/stats.min.js "></script>
    <!-- Import Map to define paths for Three.js and its addons -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from "three";
        import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
        import {OrbitControls} from "three/addons/controls/OrbitControls.js";
        import {SimplifyModifier} from "three/addons/modifiers/SimplifyModifier.js";

        // Memory Panel
        const statsMemory = new Stats();
        statsMemory.showPanel(2); // Memory
        statsMemory.dom.style.cssText = "position:absolute;top:0px;right:160px;";
        document.body.appendChild(statsMemory.dom);

        // FPS Panel
        const statsFPS = new Stats();
        statsFPS.showPanel(0); // FPS
        statsFPS.dom.style.cssText = "position:absolute;top:0px;right:80px;";
        document.body.appendChild(statsFPS.dom);

        // MS Panel
        const statsMS = new Stats();
        statsMS.showPanel(1); // MS
        statsMS.dom.style.cssText = "position:absolute;top:0px;right:0px;";
        document.body.appendChild(statsMS.dom);

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000,
        );

        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls Panel
        const controlsDiv = document.getElementById("controls");

        // Adding lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5).normalize();
        scene.add(directionalLight);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let models = [];
        let selectedModel = null;
        let selectedWireframe = null;
        let useLOD = true;

        const OFFSET = 2;
        const Y_POS = -3;
        const OFFSET_DEGREE = 15;

        // Auto add models until FPS drops below 50
        let autoAdding = false;
        let prevTime = performance.now();
        let fps = 0;
        const fpsHistory = [];
        const fpsHistorySize = 10;

        // Load GLTF model
        const loader = new GLTFLoader();
        let highDetailModel = null;
        let lowDetailModel = null;

        //default settings
        document.getElementById("useLODModel").checked = useLOD;
        document.getElementById("lodRatio").value = 0.8;
        document.getElementById("lodDistance").value = 5;

        loader.load(
            "gltf_duck/Duck.gltf",
            function (gltf) {
                highDetailModel = gltf.scene;
                createLODs();
            },
            undefined,
            function (error) {
                console.error(error);
            },
        );

        useLODModel.addEventListener("change", function () {
            useLOD = useLODModel.checked;
            updateInstance(0);
            updateInstance(numDucks.value);

            document.getElementById("lodRatio").disabled = !useLOD;
            document.getElementById("lodDistance").disabled = !useLOD;
        });

        function createLODs() {
            const modifier = new SimplifyModifier();

            if (lowDetailModel) {
                // 釋放舊的 lowDetailModel 資源
                lowDetailModel.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) {
                            child.geometry.dispose(); // 釋放幾何
                        }
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach((material) => material.dispose()); // 釋放材質（如果是材質陣列）
                            } else {
                                child.material.dispose(); // 釋放材質
                            }
                        }
                    }
                });

                // 將 lowDetailModel 從場景中移除（如果它在場景中）
                scene.remove(lowDetailModel);
                lowDetailModel = null;
            }

            // Assume the original geometry is in highDetailModel
            const sourceMesh = highDetailModel.getObjectByProperty("isMesh", true);

            if (sourceMesh) {
                // Get the geometry from the mesh
                const sourceGeometry = sourceMesh.geometry;

                const ratio = document.getElementById("lodRatio").value;
                const count = Math.floor(
                    sourceGeometry.attributes.position.count * ratio,
                );

                const lowDetailGeometry = modifier.modify(
                    sourceGeometry.clone(),
                    Math.min(sourceGeometry.attributes.position.count - 3, count),
                );

                lowDetailModel = highDetailModel.clone();
                lowDetailModel.getObjectByProperty("isMesh", true).geometry =
                    lowDetailGeometry;

                // Now you can proceed to add instances
                updateInstance(0);
                updateInstance(numDucks.value);
            }
        }

        // Function to add a new instance of the model
        function addLodInstance(position = new THREE.Vector3(), yDegree = 0) {
            console.log("Adding LOD instance");
            if (highDetailModel && lowDetailModel) {
                yDegree = yDegree % 360;
                const rad = THREE.MathUtils.degToRad(yDegree);
                const lod = new THREE.LOD();
                lod.position.copy(position);
                lod.matrix.identity();
                lod.matrixAutoUpdate = false;
                lod.matrix.multiply(new THREE.Matrix4().makeRotationY(rad));
                lod.matrix.setPosition(position);

                // Clone models and add to LOD
                const highClone = highDetailModel.clone();
                lod.addLevel(highClone, 0);

                const lowClone = lowDetailModel.clone();
                const lodDistance = document.getElementById("lodDistance").value;
                lod.addLevel(lowClone, lodDistance);

                scene.add(lod);
                models.push(lod);
            } else {
                console.log("Models not loaded yet");
            }
        }

        function addModelInstance(position = new THREE.Vector3(), yDegree = 0) {
            if (highDetailModel) {
                yDegree = yDegree % 360;
                const rad = THREE.MathUtils.degToRad(yDegree);
                const model = highDetailModel.clone();
                model.position.copy(position);
                model.matrix.identity();
                model.matrixAutoUpdate = false;
                model.matrix.multiply(new THREE.Matrix4().makeRotationY(rad));
                model.matrix.setPosition(model.position);
                scene.add(model);
                models.push(model);
            }
        }

        // Function to remove a model instance
        function removeModelInstance() {
            const model = models.pop();
            if (model) {
                for (let i = model.children.length - 1; i >= 0; i--) {
                    model.remove(model.children[i]);
                }
                scene.remove(model);
                if (selectedModel === model) {
                    selectedModel = null;
                }
            }
        }

        camera.position.x = 5;
        camera.position.y = 3;
        camera.position.z = -5;

        // Orbit Controls for better camera movement
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.update();

        const rotateX = document.getElementById("rotateX");
        const rotateY = document.getElementById("rotateY");
        const rotateZ = document.getElementById("rotateZ");
        const numDucks = document.getElementById("numDucks");

        // Set initial slider values to zero
        rotateX.value = "0";
        rotateY.value = "0";
        rotateZ.value = "0";

        autoAddButton.addEventListener("click", autoAddInstances);

        function autoAddInstances() {
            if (autoAdding) {
                autoAdding = false;
                autoAddButton.textContent = "Start";
            } else {
                autoAdding = true;
                autoAddButton.textContent = "Stop";
            }
        }

        function updateInstance(targetCount) {
            const currentCount = models.length;
            if (targetCount > currentCount) {
                for (let i = currentCount; i < targetCount; i++) {
                    if (models.length === 0) {
                        if (useLOD) {
                            addLodInstance(new THREE.Vector3(0, Y_POS, 0));
                        } else {
                            addModelInstance(new THREE.Vector3(0, Y_POS, 0));
                        }
                        continue;
                    }
                    const lastModel = models[models.length - 1];

                    let xVal = lastModel.position.x;
                    let zVal = lastModel.position.z;
                    const rotDegree = OFFSET_DEGREE * models.length;
                    let position;
                    if (zVal < 99 * OFFSET) {
                        position = lastModel.position
                            .clone()
                            .add(new THREE.Vector3(0, 0, OFFSET));
                    } else {
                        position = new THREE.Vector3(xVal - OFFSET, Y_POS, 0);
                    }
                    if (useLOD) {
                        addLodInstance(position, rotDegree);
                    } else {
                        addModelInstance(position, rotDegree);
                    }
                }
            } else if (targetCount < currentCount) {
                for (let i = currentCount; i > targetCount; i--) {
                    removeModelInstance();
                }
            }
            instanceCount.textContent = `${models.length}`;
            numDucks.value = Math.max(1, models.length);
        }

        numDucks.addEventListener("input", function () {
            updateInstance(numDucks.value);
        });

        lodRatio.addEventListener("input", function () {
            createLODs();
            lodRatioValue.textContent = (lodRatio.value * 100).toFixed(0) + "%";
        });

        lodDistance.addEventListener("input", function () {
            createLODs();
            lodDistanceValue.textContent = lodDistance.value;
        });

        // Reset the model's rotation
        function resetRotation() {
            if (selectedModel) {
                selectedModel.matrix.identity();
                selectedModel.matrix.setPosition(selectedModel.position);
            }
        }

        function updateRotation() {
            if (selectedModel) {
                const x = THREE.MathUtils.degToRad(rotateX.value);
                const y = THREE.MathUtils.degToRad(rotateY.value);
                const z = THREE.MathUtils.degToRad(rotateZ.value);

                // Reset the model's matrix
                selectedModel.matrix.identity();
                selectedModel.matrixAutoUpdate = false;

                const rotX = new THREE.Matrix4().makeRotationX(x);
                const rotY = new THREE.Matrix4().makeRotationY(y);
                const rotZ = new THREE.Matrix4().makeRotationZ(z);

                // Apply rotations in Z, Y, X order
                selectedModel.matrix.multiply(rotZ).multiply(rotY).multiply(rotX);

                selectedModel.matrix.setPosition(selectedModel.position);
                resetHighlight();
                applyHighlight(selectedModel);
            }
        }

        rotateX.addEventListener("input", updateRotation);
        rotateY.addEventListener("input", updateRotation);
        rotateZ.addEventListener("input", updateRotation);

        function selectModel(model) {
            console.log("Selected model", model);
            rotation.style.display = "block";

            selectedModel = model;

            rotateX.value = "0";
            rotateY.value = "0";
            rotateZ.value = "0";

            resetHighlight();
            applyHighlight(model);
        }

        function applyHighlight(model) {
            // Create a new group for the wireframe
            selectedWireframe = new THREE.Group();

            // Traverse the model and create wireframe meshes
            model.traverse((child) => {
                if (child.isMesh) {
                    const wireFrameMesh = child.clone();
                    const wireframeMaterial = new THREE.LineBasicMaterial({
                        color: 0xff0000,
                    });
                    wireFrameMesh.material = wireframeMaterial;

                    wireFrameMesh.matrixAutoUpdate = false;
                    wireFrameMesh.matrix.copy(child.matrixWorld);

                    selectedWireframe.add(wireFrameMesh);
                }
            });

            // Position and rotate the wireframe to match the model
            selectedWireframe.matrixAutoUpdate = false;

            scene.add(selectedWireframe);
        }

        function resetHighlight() {
            scene.remove(selectedWireframe);
            selectedWireframe = null;
        }

        function onMouseClick(event) {
            if (
                controlsDiv.contains(event.target) ||
                rotation.contains(event.target)
            ) {
                return;
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(models, true);

            if (intersects.length > 0) {
                let selectedModel = intersects[0].object;

                while (selectedModel.parent && !models.includes(selectedModel)) {
                    selectedModel = selectedModel.parent;
                }

                if (models.includes(selectedModel)) {
                    selectModel(selectedModel);
                }
            } else {
                // Deselect the model
                if (selectedModel) {
                    resetHighlight();
                    selectedModel = null;
                    rotation.style.display = "none";
                }
            }
        }

        window.addEventListener("click", onMouseClick, false);

        // ** Add Axis Indicator **

        // Create a secondary scene for the axis indicator
        const axesScene = new THREE.Scene();

        // Add an AxesHelper to the axes scene
        const axesHelper = new THREE.AxesHelper(100); // Adjust size as needed
        axesScene.add(axesHelper);

        // Create a secondary camera for the axes scene
        const axesCamera = new THREE.PerspectiveCamera(
            50, // Field of view
            1, // Aspect ratio (square)
            0.1,
            1000,
        );

        axesCamera.up = camera.up; // Ensure the camera's up vector matches the main camera's

        // ** End of Axis Indicator Setup **

        // Render loop
        function animate() {
            statsFPS.begin();
            statsMS.begin();
            statsMemory.begin();

            const currentTime = performance.now();
            const deltaTime = currentTime - prevTime;
            fps = 1000 / deltaTime;
            prevTime = currentTime;

            fpsHistory.push(fps);
            if (fpsHistory.length > fpsHistorySize) {
                fpsHistory.shift();
            }
            const avgFPS =
                fpsHistory.reduce((sum, fps) => sum + fps, 0) / fpsHistory.length;

            if (autoAdding && avgFPS > 50) {
                updateInstance(models.length + 10);
            }
            controls.update();

            // Render the main scene
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissorTest(false);
            renderer.render(scene, camera);

            // ** Render the Axis Indicator **

            // Define the size and position of the axis indicator
            const axesSize = 100; // Size in pixels
            const axesMargin = 10; // Margin from the edges

            // Set viewport and scissor for the axis indicator
            renderer.setViewport(
                window.innerWidth - axesSize - axesMargin,
                axesMargin,
                axesSize,
                axesSize,
            );
            renderer.setScissor(
                window.innerWidth - axesSize - axesMargin,
                axesMargin,
                axesSize,
                axesSize,
            );
            renderer.setScissorTest(true);
            renderer.setClearColor(0x000000, 1); // Optional: Set background color and opacity
            renderer.clearDepth(); // Clear depth buffer

            // Update the axesCamera to match the main camera's orientation
            axesCamera.position.copy(camera.position);
            axesCamera.position.sub(controls.target); // Offset by the target
            axesCamera.position.setLength(200); // Distance from the center
            axesCamera.lookAt(axesScene.position);
            axesCamera.up.copy(camera.up);

            renderer.render(axesScene, axesCamera);

            // Reset scissor test
            renderer.setScissorTest(false);

            // ** End of Axis Indicator Rendering **

            statsFPS.end();
            statsMS.end();
            statsMemory.end();

            requestAnimationFrame(animate);
            cameraPosition.textContent = `Camera Pos: (${camera.position.x.toFixed(
                2,
            )}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})`;
        }

        animate();

        // Handle window resize
        window.addEventListener("resize", function () {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
    </script>
</body>

</html>
