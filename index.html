<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Model Viewer</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="stylesheet" href="style.css" />
</head>

<body>
    <div id="controls">
        <div id="cameraPosition"></div>
        <label>
            Rotate X:
            <input type="range" id="rotateX" min="-180" max="180" value="0" />
        </label>
        <label>
            Rotate Y:
            <input type="range" id="rotateY" min="-180" max="180" value="0" />
        </label>
        <label>
            Rotate Z:
            <input type="range" id="rotateZ" min="-180" max="180" value="0" />
        </label>
        <button id="autoAddButton">Add Until FPS 50</button>
        <label>
            Set Number of Ducks:
            <input type="number" id="numDucks" min="1" max="10000" value="1" />
        </label>
        <div id="instanceCount">Instances: 1</div>
    </div>
    <script src=" https://cdn.jsdelivr.net/npm/stats-js@1.0.1/build/stats.min.js "></script>
    <!-- Import Map to define paths for Three.js and its addons -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from "three";
        import {GLTFLoader} from "three/addons/loaders/GLTFLoader.js";
        import {OrbitControls} from "three/addons/controls/OrbitControls.js";

        // MS Panel
        const statsMS = new Stats();
        statsMS.showPanel(1); // MS
        statsMS.dom.style.cssText = "position:absolute;top:0px;right:0px;";
        document.body.appendChild(statsMS.dom);

        // FPS Panel
        const statsFPS = new Stats();
        statsFPS.showPanel(0); // FPS
        statsFPS.dom.style.cssText = "position:absolute;top:0px;right:80px;";
        document.body.appendChild(statsFPS.dom);

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000,
        );
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Adding lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5).normalize();
        scene.add(directionalLight);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let models = [];
        let selectedModel = null;
        let selectedWireframe = null;

        const OFFSET = 2;
        const Y_POS = -10;

        // Auto add models until FPS drops below 50
        let autoAdding = false;
        let prevTime = performance.now();
        let fps = 0;
        const fpsHistory = [];
        const fpsHistorySize = 10;

        // Load GLTF model
        const loader = new GLTFLoader();
        let modelGLTF = null; // Cache the model

        // Function to add a new instance of the model
        function addModelInstance(position = new THREE.Vector3()) {
            if (modelGLTF) {
                const model = modelGLTF.clone();
                model.position.copy(position);
                //model.matrixAutoUpdate = false;
                scene.add(model);
                models.push(model);
            }
        }

        // Function to remove a model instance
        function removeModelInstance() {
            const model = models.pop();
            if (model) {
                scene.remove(model);
                if (selectedModel === model) {
                    selectedModel = null;
                }
            }
        }

        loader.load(
            "gltf_duck/Duck.gltf",
            function (gltf) {
                modelGLTF = gltf.scene;
                // Add the first instance of the model
                updateInstance(1);
            },
            undefined,
            function (error) {
                console.error(error);
            },
        );

        camera.position.z = 5;

        // Orbit Controls for better camera movement
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.update();

        const rotateX = document.getElementById("rotateX");
        const rotateY = document.getElementById("rotateY");
        const rotateZ = document.getElementById("rotateZ");
        const numDucks = document.getElementById("numDucks");

        // Set initial slider values to zero
        rotateX.value = "0";
        rotateY.value = "0";
        rotateZ.value = "0";

        autoAddButton.addEventListener("click", autoAddInstances);

        function autoAddInstances() {
            if (autoAdding) {
                autoAdding = false;
                autoAddButton.textContent = "Add Until FPS 50";
            } else {
                autoAdding = true;
                autoAddButton.textContent = "Stop Adding";
            }
        }

        function updateInstance(targetCount) {
            const currentCount = models.length;
            if (targetCount > currentCount) {
                for (let i = currentCount; i < targetCount; i++) {
                    if (models.length === 0) {
                        addModelInstance(new THREE.Vector3(0, Y_POS, 0));
                        continue;
                    }
                    const lastModel = models[models.length - 1];

                    let xVal = lastModel.position.x;
                    let zVal = lastModel.position.z;
                    let position;
                    if (-99 * OFFSET < zVal) {
                        position = lastModel.position
                            .clone()
                            .add(new THREE.Vector3(0, 0, -OFFSET));
                    } else {
                        position = new THREE.Vector3(xVal - OFFSET, Y_POS, 0);
                    }
                    addModelInstance(position);
                }
            } else if (targetCount < currentCount) {
                for (let i = currentCount; i > targetCount; i--) {
                    removeModelInstance();
                }
            }
            updateInstanceCount();
            camera.position.x = Math.min(10, 2 + Math.sqrt(models.length));
            camera.position.y = Math.max(8, 10 - Math.sqrt(models.length) / 3);
            camera.position.z = Math.min(10, 2 + Math.sqrt(models.length));
        }

        function updateInstanceCount() {
            instanceCount.textContent = `Instances: ${models.length}`;
        }

        numDucks.addEventListener("input", function () {
            updateInstance(numDucks.value);
        });

        // Reset the model's rotation
        function resetRotation() {
            if (selectedModel) {
                selectedModel.matrix.identity();
                selectedModel.matrix.setPosition(selectedModel.position);
            }
        }

        function updateRotation() {
            if (selectedModel) {
                const x = THREE.MathUtils.degToRad(rotateX.value);
                const y = THREE.MathUtils.degToRad(rotateY.value);
                const z = THREE.MathUtils.degToRad(rotateZ.value);

                // Reset the model's matrix
                selectedModel.matrix.identity();

                const rotX = new THREE.Matrix4().makeRotationX(x);
                const rotY = new THREE.Matrix4().makeRotationY(y);
                const rotZ = new THREE.Matrix4().makeRotationZ(z);

                // Apply rotations in Z, Y, X order
                selectedModel.matrix.multiply(rotZ).multiply(rotY).multiply(rotX);

                selectedModel.matrix.setPosition(selectedModel.position);
            }
        }

        rotateX.addEventListener("input", updateRotation);
        rotateY.addEventListener("input", updateRotation);
        rotateZ.addEventListener("input", updateRotation);

        function selectModel(model) {
            console.log("Selected model", model);

            resetHighlight(selectedModel);
            selectedModel = model;
            applyHighlight(model);

            rotateX.value = "0";
            rotateY.value = "0";
            rotateZ.value = "0";

            resetRotation();
            updateRotation();
        }

        function applyHighlight(model) {
            // Create a new group for the wireframe
            selectedWireframe = new THREE.Group();

            // Traverse the model and create wireframe meshes
            model.traverse((child) => {
                if (child.isMesh) {
                    const wireFrameMesh = child.clone();
                    const wireframeMaterial = new THREE.LineBasicMaterial({
                        color: 0xff0000,
                    });
                    wireFrameMesh.material = wireframeMaterial;

                    wireFrameMesh.matrixAutoUpdate = false;
                    wireFrameMesh.matrix.copy(child.matrixWorld);

                    selectedWireframe.add(wireFrameMesh);
                }
            });

            // Position and rotate the wireframe to match the model
            selectedWireframe.matrixAutoUpdate = false;

            console.log("model.matrix", model.matrix);

            scene.add(selectedWireframe);
        }

        function resetHighlight(model) {
            scene.remove(selectedWireframe);
            selectedWireframe = null;
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(models, true);

            if (intersects.length > 0) {
                let selectedModel = intersects[0].object;

                while (selectedModel.parent && !models.includes(selectedModel)) {
                    selectedModel = selectedModel.parent;
                }

                if (models.includes(selectedModel)) {
                    selectModel(selectedModel);
                }
            } else {
                // Deselect the model
                if (selectedModel) {
                    resetHighlight(selectedModel);
                    selectedModel = null;
                }
            }
        }

        window.addEventListener("click", onMouseClick, false);

        // Render loop
        function animate() {
            statsFPS.begin();
            statsMS.begin();

            const currentTime = performance.now();
            const deltaTime = currentTime - prevTime;
            fps = 1000 / deltaTime;
            prevTime = currentTime;

            fpsHistory.push(fps);
            if (fpsHistory.length > fpsHistorySize) {
                fpsHistory.shift();
            }
            const avgFPS =
                fpsHistory.reduce((sum, fps) => sum + fps, 0) / fpsHistory.length;

            if (autoAdding && avgFPS > 50) {
                updateInstance(models.length + 10);
            } else if (autoAdding && avgFPS < 50) {
                autoAdding = false;
                autoAddButton.textContent = "Add Until FPS 50";
            }

            controls.update();
            renderer.render(scene, camera);

            statsFPS.end();
            statsMS.end();

            requestAnimationFrame(animate);
            cameraPosition.textContent = `Camera Position: (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})`;
        }

        animate();

        // Handle window resize
        window.addEventListener("resize", function () {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
    </script>
</body>

</html>
